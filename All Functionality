#include <Arduino.h>
#include <WiFi.h>
#include <esp_now.h>
#include <ESP32Servo.h>

// Define motor pins for the H-bridges on the ESP32
const int backRightMotorPin1 = 16; // Back right motor input pin 1
const int backRightMotorPin2 = 17; // Back right motor input pin 2
const int backLeftMotorPin1 = 18;  // Back left motor input pin 1
const int backLeftMotorPin2 = 19;  // Back left motor input pin 2
const int frontRightMotorPin1 = 21; // Front right motor input pin 1
const int frontRightMotorPin2 = 22; // Front right motor input pin 2
const int frontLeftMotorPin1 = 23;  // Front left motor input pin 1
const int frontLeftMotorPin2 = 25;  // Front left motor input pin 2

// Define PWM channels
const int backRightPwmChannel1 = 0;
const int backRightPwmChannel2 = 1;
const int backLeftPwmChannel1 = 2;
const int backLeftPwmChannel2 = 3;
const int frontRightPwmChannel1 = 4;
const int frontRightPwmChannel2 = 5;
const int frontLeftPwmChannel1 = 6;
const int frontLeftPwmChannel2 = 7;

// Define servo motor pins
const int servo1Pin = 26;  // Servo motor 1 control pin
const int servo2Pin = 27;  // Servo motor 2 control pin

// Define microswitch sensor pins
const int microswitch1Pin = 32;
const int microswitch2Pin = 33;
const int microswitch3Pin = 14;

// Define reflectance sensor pins
const int reflectanceSensorLeftPin = 34;
const int reflectanceSensorRightPin = 35;

// Define IR sensor pins
const int irSensorLeftPin = 36;
const int irSensorRightPin = 39;

// Define comparator thresholds
const int reflectanceThreshold = 400;
const int reflectanceDifferenceThreshold = 50;
const int irThreshold = 500;
const int irDifferenceThreshold = 50;

// Define PWM frequency and resolution
const int pwmFrequency = 10000; // 10 kHz frequency
const int pwmResolution = 10; // 10-bit resolution, values between 0 and 1023

// Create Servo objects and track current angles
struct ServoControl {
    Servo servo;
    int currentAngle;
};

ServoControl servo1Control;
ServoControl servo2Control;

// Function to initialize motor pins and PWM channels
void initializeMotorPins() {
    pinMode(backRightMotorPin1, OUTPUT);
    pinMode(backRightMotorPin2, OUTPUT);
    pinMode(backLeftMotorPin1, OUTPUT);
    pinMode(backLeftMotorPin2, OUTPUT);
    pinMode(frontRightMotorPin1, OUTPUT);
    pinMode(frontRightMotorPin2, OUTPUT);
    pinMode(frontLeftMotorPin1, OUTPUT);
    pinMode(frontLeftMotorPin2, OUTPUT);

    // Set up PWM channels
    ledcSetup(backRightPwmChannel1, pwmFrequency, pwmResolution);
    ledcSetup(backRightPwmChannel2, pwmFrequency, pwmResolution);
    ledcSetup(backLeftPwmChannel1, pwmFrequency, pwmResolution);
    ledcSetup(backLeftPwmChannel2, pwmFrequency, pwmResolution);
    ledcSetup(frontRightPwmChannel1, pwmFrequency, pwmResolution);
    ledcSetup(frontRightPwmChannel2, pwmFrequency, pwmResolution);
    ledcSetup(frontLeftPwmChannel1, pwmFrequency, pwmResolution);
    ledcSetup(frontLeftPwmChannel2, pwmFrequency, pwmResolution);

    // Attach PWM channels to motor pins
    ledcAttachPin(backRightMotorPin1, backRightPwmChannel1);
    ledcAttachPin(backRightMotorPin2, backRightPwmChannel2);
    ledcAttachPin(backLeftMotorPin1, backLeftPwmChannel1);
    ledcAttachPin(backLeftMotorPin2, backLeftPwmChannel2);
    ledcAttachPin(frontRightMotorPin1, frontRightPwmChannel1);
    ledcAttachPin(frontRightMotorPin2, frontRightPwmChannel2);
    ledcAttachPin(frontLeftMotorPin1, frontLeftPwmChannel1);
    ledcAttachPin(frontLeftMotorPin2, frontLeftPwmChannel2);
}

// Function to initialize additional I/O pins
void initializeIOPins() {
    // Initialize servo motor pins and set initial angles
    servo1Control.servo.attach(servo1Pin);
    servo2Control.servo.attach(servo2Pin);
    servo1Control.currentAngle = 90; // Initial angle
    servo2Control.currentAngle = 90; // Initial angle
    servo1Control.servo.write(servo1Control.currentAngle);
    servo2Control.servo.write(servo2Control.currentAngle);

    // Initialize microswitch sensor pins
    pinMode(microswitch1Pin, INPUT_PULLUP); // Assuming the microswitch is active low
    pinMode(microswitch2Pin, INPUT_PULLUP);
    pinMode(microswitch3Pin, INPUT_PULLUP);

    // Reflectance sensors are initialized by default for analog reading
    // IR sensors are initialized by default for analog reading
}

// Function to control motor speed and direction with PWM
void setMotorSpeed(int pwmChannel1, int pwmChannel2, bool direction, int speed) {
    if (direction) {
        // Forward direction
        ledcWrite(pwmChannel1, speed);
        ledcWrite(pwmChannel2, 0);
    } else {
        // Backward direction
        ledcWrite(pwmChannel1, 0);
        ledcWrite(pwmChannel2, speed);
    }
}

// Function to apply dynamic braking
void dynamicBrakeMotor(int pwmChannel1, int pwmChannel2) {
    // Stops the motor by maximizing speed in opposite direction
    int currentSpeed1 = ledcRead(pwmChannel1);
    int currentSpeed2 = ledcRead(pwmChannel2);

    if (currentSpeed1 > 0) {
        // Current direction is forward, brake by reversing
        ledcWrite(pwmChannel1, 0);
        ledcWrite(pwmChannel2, 1023);
    } else if (currentSpeed2 > 0) {
        // Current direction is backward, brake by moving forward
        ledcWrite(pwmChannel1, 1023);
        ledcWrite(pwmChannel2, 0);
    }

    // Short delay to apply braking force
    delay(20); // Adjust delay time based on testing

    // Set both motor speeds to zero to keep the motor still
    ledcWrite(pwmChannel1, 0);
    ledcWrite(pwmChannel2, 0);
}

// Function to drive the robot forward
void driveForward(int speed) {
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, true, speed);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, true, speed);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, true, speed);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, true, speed);
}

// Function to drive the robot backward
void driveBackward(int speed) {
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, false, speed);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, false, speed);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, false, speed);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, false, speed);
}

// Function to drive the robot to the left
void driveLeft(int speed) {
    int adjustedSpeed = speed * 1.1;
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, false, speed);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, true, adjustedSpeed);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, true, adjustedSpeed);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, false, speed);
}

// Function to drive the robot to the right
void driveRight(int speed) {
    int adjustedSpeed = speed * 1.1;
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, true, adjustedSpeed);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, false, speed);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, false, speed);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, true, adjustedSpeed);
}

// Function to rotate the robot 180 degrees
void rotate180(int speed) {
    // Set the wheels on one side to move forward and the wheels on the other side to move backward
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, true, speed);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, false, speed);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, true, speed);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, false, speed);

    int rotateTime = 500; // This is subject to testing
    delay(rotateTime);

    // Stop all motors
    setMotorSpeed(frontLeftPwmChannel1, frontLeftPwmChannel2, true, 0);
    setMotorSpeed(frontRightPwmChannel1, frontRightPwmChannel2, false, 0);
    setMotorSpeed(backLeftPwmChannel1, backLeftPwmChannel2, true, 0);
    setMotorSpeed(backRightPwmChannel1, backRightPwmChannel2, false, 0);
}

// Function to stop the robot
void stopRobot() {
    dynamicBrakeMotor(frontLeftPwmChannel1, frontLeftPwmChannel2);
    dynamicBrakeMotor(frontRightPwmChannel1, frontRightPwmChannel2);
    dynamicBrakeMotor(backLeftPwmChannel1, backLeftPwmChannel2);
    dynamicBrakeMotor(backRightPwmChannel1, backRightPwmChannel2);
}

// Function to set the angle of servo motors and track current angle
void setServoAngle(ServoControl &servoControl, int angle) {
    servoControl.servo.write(angle);
    servoControl.currentAngle = angle;
}

// Function to get the current angle of a servo motor
int getServoAngle(ServoControl &servoControl) {
    return servoControl.currentAngle;
}

// Function to check if a microswitch is pressed
bool isMicroswitchPressed(int pin) {
    return digitalRead(pin) == LOW; // Assuming active low configuration
}

// Function to read sensor values (reflectance or IR)
int readSensor(int pin) {
    return analogRead(pin);
}

enum Direction {
    LEFT,
    RIGHT,
    CENTERED,
    NOT_ON_LINE
};

// Function to determine which direction to move the robot given the reflectance sensor readings
Direction determineReflectanceDirection(int leftSensor, int rightSensor) {
    if (leftSensor >= reflectanceThreshold && rightSensor >= reflectanceThreshold) {
        return NOT_ON_LINE;
    } else if (abs(leftSensor - rightSensor) < reflectanceDifferenceThreshold) {
        return CENTERED;
    } else if (leftSensor < reflectanceThreshold && rightSensor >= reflectanceThreshold) {
        return LEFT;
    } else if (rightSensor < reflectanceThreshold && leftSensor >= reflectanceThreshold) {
        return RIGHT;
    } else if (leftSensor < rightSensor) {
        return LEFT;
    } else {
        return RIGHT;
    }
}

// Function to determine which direction to move the robot given the IR sensor readings
Direction determineIRDirection(int leftSensor, int rightSensor) {
    if (leftSensor >= irThreshold && rightSensor >= irThreshold) {
        return NOT_ON_LINE;
    } else if (abs(leftSensor - rightSensor) < irDifferenceThreshold) {
        return CENTERED;
    } else if (leftSensor < irThreshold && rightSensor >= irThreshold) {
        return LEFT;
    } else if (rightSensor < irThreshold && leftSensor >= irThreshold) {
        return RIGHT;
    } else if (leftSensor < rightSensor) {
        return LEFT;
    } else {
        return RIGHT;
    }
}

void setup() {
    // Initialize serial communication for debugging
    Serial.begin(115200);

    // Initialize motor pins and PWM channels
    initializeMotorPins();

    // Initialize additional I/O pins
    initializeIOPins();

    // Print a message to indicate setup completion
    Serial.println("Setup complete.");

    // Initialize WiFi for ESP-NOW
    WiFi.mode(WIFI_STA);
    if (esp_now_init() != ESP_OK) {
        Serial.println("Error initializing ESP-NOW");
        return;
    }
    Serial.println("ESP-NOW initialized.");
}

void loop() {
    // Example testing instructions (replace with actual logic)
    // Read the reflectance sensor values
    int reflectanceSensorLeftValue = readSensor(reflectanceSensorLeftPin);
    int reflectanceSensorRightValue = readSensor(reflectanceSensorRightPin);

    // Determine the direction to move based on reflectance sensor readings
    Direction reflectanceDirection = determineReflectanceDirection(reflectanceSensorLeftValue, reflectanceSensorRightValue);

    switch (reflectanceDirection) {
        case CENTERED:
            Serial.println("Robot is centered on the black line.");
            stopRobot(); // Stop the robot if it is centered
            break;
        case LEFT:
            Serial.println("Robot needs to move left.");
            driveLeft(100); // Adjust speed based on testing
            break;
        case RIGHT:
            Serial.println("Robot needs to move right.");
            driveRight(100); // Adjust speed based on testing
            break;
        case NOT_ON_LINE:
            Serial.println("Robot is not on the black line.");
            driveForward(100); // Adjust speed based on testing or implement your search logic here
            break;
    }

    // Read the IR sensor values
    int irSensorLeftValue = readSensor(irSensorLeftPin);
    int irSensorRightValue = readSensor(irSensorRightPin);

    // Determine the direction to move based on IR sensor readings
    Direction irDirection = determineIRDirection(irSensorLeftValue, irSensorRightValue);

    switch (irDirection) {
        case CENTERED:
            Serial.println("Robot is centered on the IR beacon.");
            stopRobot(); // Stop the robot if it is centered
            break;
        case LEFT:
            Serial.println("Robot needs to move left towards the IR beacon.");
            driveLeft(100); // Adjust speed based on testing
            break;
        case RIGHT:
            Serial.println("Robot needs to move right towards the IR beacon.");
            driveRight(100); // Adjust speed based on testing
            break;
        case NOT_ON_LINE:
            Serial.println("IR beacon not detected.");
            driveForward(100); // Adjust speed based on testing or implement your search logic here
            break;
    }

    delay(100); // Small delay to avoid overwhelming the serial output
}
